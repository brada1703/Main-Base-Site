var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
import { OpaqueToken } from '@angular/core';
import { Observable } from 'rxjs/Observable';
import 'rxjs/add/observable/forkJoin';
import 'rxjs/add/operator/toPromise';
import 'rxjs/add/operator/share';
var LOCALIZE_LOCAL_STORAGE = 'LOCALIZE_LOCAL_STORAGE';
/**
 * Static provider for keeping track of routes
 * @type {OpaqueToken}
 */
export var RAW_ROUTES = new OpaqueToken('RAW_ROUTES');
/**
 * Abstract class for parsing localization
 */
export var LocalizeParser = (function () {
    /**
     * Loader constructor
     * @param translate
     * @param location
     */
    function LocalizeParser(translate, location) {
        this.translate = translate;
        this.location = location;
    }
    /**
     * Initialize language and routes
     * @param routes
     * @returns {Promise<any>}
     */
    LocalizeParser.prototype.init = function (routes) {
        var selectedLanguage;
        var wildcardRoute;
        this.routes = routes;
        if (!this.locales.length) {
            return Promise.resolve();
        }
        /** detect current language */
        var locationLang = this.getLocationLang();
        this.defaultLang = this._cachedLang || this._getBrowserLang() || this.locales[0];
        selectedLanguage = locationLang || this.defaultLang;
        this.translate.setDefaultLang(this.defaultLang);
        /** set base route */
        var baseRoute = { path: '', redirectTo: this.defaultLang, pathMatch: 'full' };
        /** extract potential wildcard route */
        var wildcardIndex = routes.findIndex(function (route) { return route.path === '**'; });
        if (wildcardIndex !== -1) {
            wildcardRoute = routes.splice(wildcardIndex, 1)[0];
        }
        /** mutable operation on routes */
        var children = this.routes.splice(0, this.routes.length, baseRoute);
        /** append children routes... */
        this.routes.push({ children: children });
        /** ...and potential wildcard route */
        if (wildcardRoute) {
            this.routes.push(wildcardRoute);
        }
        /** translate routes */
        var res = this.translateRoutes(selectedLanguage);
        return res.toPromise();
    };
    LocalizeParser.prototype.initChildRoutes = function (routes) {
        if (!this.translationObject) {
            // not lazy, it will be translated in main init
            return routes;
        }
        this._translateRouteTree(routes);
        return routes;
    };
    /**
     * Translate routes to selected language
     * @param language
     * @returns {Promise<any>}
     */
    LocalizeParser.prototype.translateRoutes = function (language) {
        var _this = this;
        return new Observable(function (observer) {
            _this._cachedLang = language;
            if (_this.routes.length > 1) {
                _this.routes[1].path = language;
            }
            _this.translate.use(language).subscribe(function (translations) {
                _this.translationObject = translations;
                _this.currentLang = language;
                if (_this.routes.length > 1) {
                    _this._translateRouteTree(_this.routes[1].children);
                }
                // if there is wildcard route
                if (_this.routes.length > 2 && _this.routes[2].redirectTo) {
                    _this._translateProperty(_this.routes[2], 'redirectTo', true);
                }
                observer.next(void 0);
                observer.complete();
            });
        });
    };
    /**
     * Translate the route node and recursively call for all it's children
     * @param routes
     * @returns {Promise<any>}
     * @private
     */
    LocalizeParser.prototype._translateRouteTree = function (routes) {
        var _this = this;
        routes.forEach(function (route) {
            if (route.path && route.path !== '**') {
                _this._translateProperty(route, 'path');
            }
            if (route.redirectTo) {
                _this._translateProperty(route, 'redirectTo', !route.redirectTo.indexOf('/'));
            }
            if (route.children) {
                _this._translateRouteTree(route.children);
            }
            if (route.loadChildren && route._loadedConfig) {
                _this._translateRouteTree(route._loadedConfig.routes);
            }
        });
    };
    /**
     * Translate property and if first time add original to cache
     * @param route
     * @param property
     * @param prefixLang
     * @private
     */
    LocalizeParser.prototype._translateProperty = function (route, property, prefixLang) {
        // set property to data if not there yet
        var dataPointer = route.data = route.data || {};
        if (!dataPointer.localizeRouter) {
            dataPointer.localizeRouter = {};
        }
        if (!dataPointer.localizeRouter[property]) {
            dataPointer.localizeRouter[property] = route[property];
        }
        var result = this.translateRoute(dataPointer.localizeRouter[property]);
        route[property] = prefixLang ? "/" + this.currentLang + result : result;
    };
    /**
     * Translate route and return observable
     * @param path
     * @returns {string}
     */
    LocalizeParser.prototype.translateRoute = function (path) {
        var _this = this;
        var pathSegments = path.split('/');
        /** collect observables  */
        return pathSegments.map(function (part) { return part.length ? _this.translateText(part) : part; }).join('/');
    };
    /**
     * Get language from url
     * @returns {any}
     * @private
     */
    LocalizeParser.prototype.getLocationLang = function (url) {
        var pathSlices = (url || this.location.path()).split('/');
        if (pathSlices.length > 1 && this.locales.indexOf(pathSlices[1]) !== -1) {
            return pathSlices[1];
        }
        if (pathSlices.length && this.locales.indexOf(pathSlices[0]) !== -1) {
            return pathSlices[0];
        }
        return null;
    };
    /**
     * Get user's language set in the browser
     * @returns {any}
     * @private
     */
    LocalizeParser.prototype._getBrowserLang = function () {
        return this._returnIfInLocales(this.translate.getBrowserLang());
    };
    Object.defineProperty(LocalizeParser.prototype, "_cachedLang", {
        /**
         * Get language from local storage
         * @returns {string}
         * @private
         */
        get: function () {
            if (typeof window === 'undefined' || typeof window.localStorage === 'undefined') {
                return undefined;
            }
            return this._returnIfInLocales(window.localStorage.getItem(LOCALIZE_LOCAL_STORAGE));
        },
        /**
         * Save language to local storage
         * @param value
         * @private
         */
        set: function (value) {
            if (typeof window === 'undefined' || typeof window.localStorage === 'undefined') {
                return;
            }
            window.localStorage.setItem(LOCALIZE_LOCAL_STORAGE, value);
        },
        enumerable: true,
        configurable: true
    });
    LocalizeParser.prototype._returnIfInLocales = function (value) {
        if (value && this.locales.indexOf(value) !== -1) {
            return value;
        }
        return null;
    };
    LocalizeParser.prototype.translateText = function (key) {
        if (!this.translationObject) {
            return key;
        }
        var res = this.translationObject[this.prefix + key];
        return res || key;
    };
    return LocalizeParser;
}());
/**
 * Manually set configuration
 */
export var ManualParserLoader = (function (_super) {
    __extends(ManualParserLoader, _super);
    /**
     * CTOR
     * @param translate
     * @param location
     * @param locales
     * @param prefix
     */
    function ManualParserLoader(translate, location, locales, prefix) {
        if (locales === void 0) { locales = ['en']; }
        if (prefix === void 0) { prefix = 'ROUTES.'; }
        _super.call(this, translate, location);
        this.locales = locales;
        this.prefix = prefix;
    }
    /**
     * Initialize or append routes
     * @param routes
     */
    ManualParserLoader.prototype.load = function (routes) {
        var _this = this;
        return new Promise(function (resolve) {
            _this.init(routes).then(resolve);
        });
    };
    return ManualParserLoader;
}(LocalizeParser));
/**
 * Load configuration from server
 */
export var StaticParserLoader = (function (_super) {
    __extends(StaticParserLoader, _super);
    /**
     * CTOR
     * @param translate
     * @param location
     * @param http
     * @param path
     */
    function StaticParserLoader(translate, location, http, path) {
        if (path === void 0) { path = 'assets/locales.json'; }
        _super.call(this, translate, location);
        this.http = http;
        this.path = path;
        this._dataLoaded = false;
    }
    /**
     * Initialize or append routes
     * @param routes
     */
    StaticParserLoader.prototype.load = function (routes) {
        var _this = this;
        return new Promise(function (resolve) {
            if (_this._dataLoaded) {
                _this.init(routes).then(resolve);
            }
            else {
                _this.http.get("" + _this.path)
                    .map(function (res) { return res.json(); })
                    .subscribe(function (data) {
                    _this._dataLoaded = true;
                    _this.locales = data.locales;
                    _this.prefix = data.prefix;
                    _this.init(routes).then(resolve);
                });
            }
        });
    };
    return StaticParserLoader;
}(LocalizeParser));
